TARGET DECK
School::CMPT 332::01.7 - Operating System Structure

In the following Section, we will examining six different structures that have been tried when developing operating systems.

# Monolithic Systems <!--fc-->
The most common organization, the OS is ran as a single program in kernel mode.
To construct this actual program, all of the individual procedures are compiled and then bound together into a single executable using the system linker.

## Structure of monolithic OS <!--fc-->
The basic structure for this type of OS is
- a main procedure that invokes everything else
- a set of service procedures
- a set of utility procedures for those service procedures.
![[Pasted image 20240729074501.png]]

## Shared Libraries <!--fc-->
Components that are loaded on demand, not bound to main program at compile time

# Layered Systems <!--fc-->
A generalization of the monolithic approach, it is to organize the OS as a hierarchy of layers, each one constructed upon the layer below it.
![[Pasted image 20240729080708.png]]
With the layered approach, designers have a choice of where to draw the kernel-user boundary

# Microkernels <!--fc-->
A strong case can be made for putting as little possible of the OS in kernel mode because bugs in the kernel can bring down the system instantly.
- Achieve high reliability by splitting the OS up into small, well defined modules, only one of which, the kernel, runs in kernel mode.
![[Pasted image 20240729085715.png]]
Outside the kernel, the system is structured as three layers of processes all running in user mode. The lowest layer contains the device drivers.
TO grogram an IO device, the driver builds a structure telling which values to write to which IO ports and makes a kernel call telling the kernel to do the write.

## Servers in Microkernel <!--fc-->
Do most of the work of the OS. *Not network servers*
One or more file servers manage the file system, the process manager manages processes, and so on.\
\
### Reincarnation server <!--fc-->
Checks if the other servers and drivers are functioning correctly. In the even a faulty one is detected, it is automatically replaced without any user intervention.

## POLA (Principle of Least Authority) <!--fc-->
Restricting what a component can do to exactly what it needs to do its work.
E.g.: The MINIX system access to kernel calls is controlled on a per-process basis, as is the ability to send messages to other processes. 
Processes can grant limited permission for other processes to have kernel access to their address space (file system can grant permission for the disk driver to let kernel put new block at specific address)


# Client-Server Model <!--fc-->
Distinguishes two classes of processes
- Servers - which provides some service
- Clients - Make use of the services
Communication between clients and servers is often by message passing.
This can be used for a single machine or a network of machines, i.e.: clients and servers run on different computers, connected by a local or wide area network
![[Pasted image 20240729104257.png]]


# Virtual Machines