TARGET DECK
Home::A Tour of C++::06 - Essential Operations

# Essential Operations <!--fc-->
Constructors, destructors, copy, and move operations for a type are not logically separate. We must define them as a matched set or suffer logical or performance problems
![[Pasted image 20240614143059.png]]
For example, there are five situations in which an object can be copied or moved
- Source of an assignment
- Object initializer
- Function argument
- Function return value
- As an exception
<!--ID: 1718568606444-->


## Default special functions <!--fc-->
Essential operations will be generated by the compiler by default. If you want to be explicit, you can do this
![[Pasted image 20240614143422.png]]
<!--ID: 1718568606455-->


## Copy and move in classes with pointer members <!--fc-->
If a class has a pointer member, you may want to be explicit about copy and move operations. The pointer may point to something which the class needs to `delete`, which the default copy may not do correctly.
<!--ID: 1718568606465-->


## Rule of zero <!--fc-->
Either define all essential operations, or none (using the default for all) for readability purposes
![[Pasted image 20240614143813.png]]
Here, the compiler will synthesize memberwise default construction, copy, move, and destruction as needed
<!--ID: 1718568606475-->


## `=delete` <!--fc-->
To complement `=default`, you can use `=delete` to ensure that an operation is not to be generated.
A good example of this is a base class, which we usually don't want memberwise copying to be defined
![[Pasted image 20240614144024.png]]
<!--ID: 1718568606485-->



# Conversions <!--fc-->
A constructor taking a single argument defines a conversion form its argument type. 
For example, `complex` provides a constructor from a `double`:
```C++
complex z1 = 3.14; // z1 becomes {3.14,0.0}
complex z2 = z1∗2; // z2 becomes z1*{2.0,0} == {6.28,0.0}
```
<!--ID: 1718568606496-->


## Explicit conversion <!--fc-->
Implicit conversion is not always ideal, for example
```C++
Vector v1 = 7; //v1 has 7 elements
```
This can be sort of confusing, so we can make it so only explicit conversion is allowed
```C++
class Vector {
public:
	explicit Vector(int s) //no implicit conversion allowed
}
```
This gives us
```C++
Vector v1(7); //Ok
Vector v2 = 7; //ERROR
```
<!--ID: 1718568606506-->



# Member Initializers <!--fc-->
When a data member of a class is defined, we can supply a default initializer called a *default member initializer*
![[Pasted image 20240615222633.png]]
<!--ID: 1718568606515-->


# Copy and Move <!--fc-->
By default, objects can be copied. The default meaning of copy is memberwise copy; copy each member
![[Pasted image 20240616120726.png]]
Now `z1`, `z2`, and `z3` all have the same value. For sophisticated types like `vector`, memberwise copy isn't what you want to do
<!--ID: 1718568606525-->


## Copying Containers <!--fc-->
When a class is a *resource handle*; a class is responsible of an object accessed through a pointer, the default copy will just make the new object point to the same elements as the original
![[Pasted image 20240616125449.png]]
Copying of an object is defined by two members; *copy constructor* and *copy assignment*.
![[Pasted image 20240616125642.png]]
<!--ID: 1718568606535-->


### Copy Constructor <!--fc-->
A copy constructor would allocate the space for the required number of elements and then copy the elements into it so each object has a distinct copy of the elements.
![[Pasted image 20240616125828.png]]
<!--ID: 1718568606545-->


### Copy Assignment <!--fc-->
This copies another object's data into the current
![[Pasted image 20240616130432.png]]
The elements are copied before the old elements are deleted so that if something goes wrong the old value can be preserved
<!--ID: 1718568606555-->


## Moving Containers <!--fc-->
Copying can be costly for large containers. We can return references, but not for local objects since the function is destroyed on return.
Consider:
```C++
Vector operator+(const Vector& a, const Vector& b) {
	if (a.size()!=b.size())
		throw Vector_size_mismatch{};
	Vector res(a.size());
	for (int i=0; i!=a.size(); ++i)
		res[i]=a[i]+b[i];
	return res;
}
```
returning from a `+` involves copying the result out of the local variable `res` and into some place where the caller can access it. We do not want to do this. We want to *move* instead of copy
![[Pasted image 20240616135355.png]]
Move constructor:
![[Pasted image 20240616135501.png]]
A move constructor does not take a `const` argument. It's supposed to remove the value from it's argument
<!--ID: 1718568606565-->


## rvalue reference <!--fc-->
This is what `&&` means. It is a reference to which we can bind an rvalue. lvalue means something that can appear on the left-hand of an assignment. An rvalue is a value you can't assign to, such as an integer returned by a function call. Since it can't be assigned to, we can safely 'steal' it's value.
<!--ID: 1718568606575-->


## Move assignment <!--fc-->
A move operation is applied when an rvalue reference is used as an initializer (polymorphism) or as the right-hand side of an assignment. 
<!--ID: 1718568606585-->


## `move()` <!--fc-->
Since the move operator deletes the original, the compiler may not always know, so you can be specific
![[Pasted image 20240616140414.png]]
The standard library function `move()` doesn't move anything, it just returns a reference to the argument which we may move, an *rvalue reference*; it is a kind of cast.
![[Pasted image 20240616140514.png]]
<!--ID: 1718568606595-->


# Resource Management <!--fc-->
By defining constructors, copy operations, move operations, and a destructor, a programmer can provide complete control of the lifetime of a contained resource (such as the elements of a container). Furthermore, a move constructor allows an object to move simply and cheaply from one scope to another.
It's better to use objects that have resource management abstracted away than working directly with bare pointers for example, as it lowers the likelihood of errors.
<!--ID: 1718833462435-->


## Garbage Collection <!--fc-->
Garbage collectors can be plugged in, however it's better to set up these essential operations for objects instead, to make garbage collection unnecessary.
Let each resource have an owner in some scope and by default be released at the end of its owner's scope. The is called RAII (Resource Acquisition is Initialization)
<!--ID: 1718833462443-->


# Operator Overloading <!--fc-->
We can give meaning to C++'s operators for user defined types
Rules:
- It is not possible to define new operators, e.g.: `^^`, `===`
- ![[Pasted image 20240619154646.png]]
<!--ID: 1718835063606-->


## Overloaded operators as member functions <!--fc-->
Operators can be defined as member functions, and this is conventionally done for operators that modify their first operand and for historical reasons is required for `=`, `->`, `()`, and `[]`
```C++
class Matrix {
// ...
Matrix& operator=(const Matrix& a); // assign m to *this; return a reference to *this
}
```
<!--ID: 1718835063621-->


## Overloaded operators and free-standing functions <!--fc-->
It is conventional to define operators with symmetric operands as free-standing functions so that both operands are treaded identically
```C++
Matrix operator+(const Matrix& m1, const Matrix& m2); // assign m1 to m2 and return the sum
```
<!--ID: 1718835063626-->


# Conventional Operations <!--fc-->
Some operations have conventional meaning when defined for a type. These conventional meanings are often assumed by programmers and libraries, so it is wise to conform to them.
![[Pasted image 20240619155141.png]]
<!--ID: 1718835063630-->


## Comparisons (Relational Operators) <!--fc-->
The meaning of equality comparisons (`==` and `!=`) is closely related to copying. After a copy, the copies should compare equal
![[Pasted image 20240619155427.png]]
- When defining `==`, also define `!=` and make sure it means `!(a==b)`
- ![[Pasted image 20240619155508.png]]
Define these as free standing operators to make sure both operands are treated identically.
<!--ID: 1718835063634-->


### Spaceship Operator `<=>` <!--fc-->
Works similar to C's `strcmp()`. A negative return value means less, 0 means equal, positive means greater.
If `<=>` is defined and non default, `<` and `>` are also implicitly defined, but not `==`
- Since `<=>` examines elements one at a time, it's useful to provide a separate optimized `==`
<!--ID: 1718921659272-->


## Container Operations <!--fc-->
You should design containers in the style of the standard-library containers. In particular, *make the container resource safe by implementing it as a handle with appropriate essential operations*.
<!--ID: 1718921659286-->


### Get number of elements in container <!--fc-->
Make the function `size()` return the number of elements.
<!--ID: 1718921659300-->


### Iteration through containers <!--fc-->
Rather than traversing containers using indices for `0` to `size()`, the standard algorithms rely on the notion of *sequences* delimited by pairs of `iterators`.
```C++
for (auto p = c.begin(); p!=c.end(); ++p)
	∗p = 0;
```
`c.begin()` is an iterator pointing to the first element of `c` and `c.end()` points to one beyond the last element of `c`. Like pointers, iterators support `++` to move to the next element and `*` to access the value of the pointed to elements.
- `begin()` and `end()` are also used by the range-`for`, so we can simplify this to
```C++
for (auto& x : c)
	x = 0;
```


### Passing sequences to standard-library functions <!--fc-->
This is done with iterators
```C++
sort(v.begin(), v.end());
```
The versions of `begin()` and `end()` for `const` containers are called `cbegin()` and `cend()`.


## Iterators and "smart pointers" <!--fc-->
User defined iterators and 'smart pointers' implement the operators and aspects of a pointer desired for their purpose and often add semantics as needed
![[Pasted image 20240620175912.png]]
<!--ID: 1718927960600-->

## Input and Output Operators <!--fc-->
For pairs of integers, `<<` and `>>` mean left shift and right shift. For iostreams, however, they are input and output operators
<!--ID: 1718936020171-->


## `swap()` <!--fc-->
Many algorithms, like `sort()`, use a `swap()` function that exchanges the values of two objects. Such algorithms assume `swap()` is fast and doesn't throw an exception.
- The standard library provides `std::swap(a,b)` implemented as three move operations. 
<!--ID: 1718936020194-->


## `hash<>` <!--fc-->
The standard library `unordered_map<K,V>` is a hash table with `K` as the key type and `V` as the value type. To use a type `X` as a key, we must define `hash<X`. For common types, the standard library defines `hash<>` for us.
<!--ID: 1718936020204-->


# User Defined Literals
It can be useful to provide literals as user-defined types. This is done by defining the meaning of a suitable suffix to a literal, such as:
![[Pasted image 20240620200957.png]]
We can get these examples from the standard library by using suitable headers and namespaces:
![[Pasted image 20240620201125.png]]
Literals with user defined suffixes are called 'user defined literals', or 'UDLs'. These are defined with *literal operators*
![[Pasted image 20240620201228.png]]

